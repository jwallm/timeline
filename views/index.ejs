<%- include('partials/header') %>

<style>

    body {
        margin:0;
        padding:0;
        border:0;
        outline: none;
        line-height: 1;
        border-collapse: collapse;
        border-spacing: 0;
        quotes: none;
        display:block;
        font: inherit;
        font-size: 100%;
        vertical-align: baseline;
    }

    #TL_ZONE{
        outline: solid 1px black;
        min-width:95%;
        max-width: 95%;
        min-height: 500px;
        margin:20px;
    }
    #TL_ZONE_INNER{
        min-width: <%= tl_width %>;
        max-width: <%= tl_width %>;
    }
    .TL_LANE{
        width: 100%;
        min-width: 100%;
        min-height: 100px;
        max-height:100px;
        overflow:hidden;
        outline: 1px dotted red;
        position:relative;
    }
    .PROTO{
        display:none;
    }
    .TL_ELEMENT{
        border: solid 3px green;
        min-height: 50px;
    }
    .TL_ELEMENT p{
        margin: 10px;
    }

    .TL_ELEMENT_SHRUNK_SHOW{
        background: linear-gradient(90deg,rgba(255, 255, 0, 1) 5%, rgba(255, 255, 255, .8) 100%);
        border: 3px solid transparent;
        border-image: linear-gradient(90deg,rgba(0, 100, 0, 1) 10%, rgba(0, 100, 0, 0) 100%);
        border-image-slice: 1;

        /*background-color: red;*/
        /*border: none;*/
        /*mask: conic-gradient(from -135deg at right,#0000,#000 1deg 89deg,#0000 90deg) 50%/100% 20px;*/
        min-width: <%= min_child_width %>px !important;
        width: <%= min_child_width %>px !important;
        /*mask: conic-gradient(from -135deg at right,#0000,#000 1deg 89deg,#0000 90deg) 50%/100% 20px;
        background-color: red;*/
    }
    .TL_ELEMENT_NO_END{
        /*background: linear-gradient(90deg,rgba(255, 255, 0, 1) 5%, rgba(255, 255, 255, .8) 100%);
        border: 3px solid transparent;
        border-image: linear-gradient(90deg,rgba(0, 100, 0, 1) 10%, rgba(0, 100, 0, 0) 100%);
        border-image-slice: 1;*/

        /*background-color: red;*/
        /*border: none;*/
        /*mask: conic-gradient(from -135deg at right,#0000,#000 1deg 89deg,#0000 90deg) 50%/100% 20px;*/
        min-width: <%= min_child_width %>px !important;
        width: <%= min_child_width %>px !important;
        mask: conic-gradient(from -135deg at right,#0000,#000 1deg 89deg,#0000 90deg) 50%/100% 20px;
        background-color: red;
    }
    .TL_ELEMENT_SHRUNK_HIDE{
        display: none;
        /*min-width: <%= min_child_width %>px !important;
        width: <%= min_child_width %>px !important;*/
    }

    #TL_RULER{
        position: relative;
        top:12px;
    }
    #TL_RULER canvas{
        min-width:100%;
        height: 50px;
        margin: 0px 20px;
    }

    #TL_MAIN_ELEMENT_NAME {
        margin:20px;
        cursor: -moz-zoom-out;
        cursor: -webkit-zoom-out;
        cursor: zoom-out;

    }
    #TL_MAIN_ELEMENT{
        min-width:100%;
        max-width:100%;
        min-height: 100px;
    }
    .TL_ELEMENT_CHILD{
        top: 4px;
        position: absolute;
    }
    .arrow-up {
        width: 0;
        height: 0;
        border-left: 10px solid transparent;
        border-right: 10px solid transparent;
        border-bottom: 10px solid red;
    }
    .arrow-up_UNSEEN {
        border-bottom: 10px solid purple;
    }

    .RULER_MARKER_BOT{
        min-width:20px;
        max-width:20px;
        min-height:15px;
        max-height:15px;
        border-radius: 1px 1px 10px 10px;
        background-color:red;
        color: white;
    }

    .RULER_MARKER_BOT span.elements_number{
        position: relative;
        top: -5px;
        right: -6px;
    }

    .RULER_MARKER_BOT_UNSEEN{
        background-color:purple;
    }

    .RULER_MARKER{
        position: absolute;
        min-width:20px;
        min-height:20px;
        max-width:20px;
        max-height:20px;
        margin-top:-5px;
        cursor: -moz-zoom-in;
        cursor: -webkit-zoom-in;
        cursor: zoom-in;
    }
    #RULER_MARKER_ORIGINAL{
        display:none;
    }

    .tooltip {
        position: relative;
        display: inline-block;
        border-bottom: 1px dotted black;
    }

    .RULER_MARKER .tooltiptext {
        visibility: hidden;
        width: 500px;
        background-color: #555;
        color: #fff;
        text-align: center;
        border-radius: 6px;
        padding: 5px 0;
        position: absolute;
        z-index: 10;
        bottom: 30px;
        left: 50%;
        margin-left: -60px;
        opacity: 0.2;
        transition: opacity 0.5s;

    }

    .RULER_MARKER:hover .tooltiptext {
        visibility: visible;
        opacity: 0.85;

    }

</style>

<script type="text/javascript" defer>
    const min_child_width = '<%= min_child_width %>';
    document.addEventListener("DOMContentLoaded", (event) => {

        const fetch_url = '<%= fetch_url %>';
        const zoom = 0;
        const offset_element = '<%= offset_element %>';

        $(window).bind('resize', function(e)
        {
            if (window.RT) clearTimeout(window.RT);
            window.RT = setTimeout(function()
            {
                this.location.reload(false); /* false to get page from cache */
            }, 1000);
        });

        if($('#TL_ZONE_INNER').width() > $('#TL_ZONE').width()){
            $('#TL_ZONE').css('overflow-x','scroll');
        }

        var time_line_data = fetch(fetch_url)
            .then(response => response.json())
            .then(function (data) {
                //console.log(data);
                //console.log(data.data);

                const tl_data = data.data;
                const children = tl_data.children;

                //console.log("years : " + tl_data.main.year_duration);

                //let zone_wdth = $('#TL_ZONE').width();

                tl_title = tl_data.main.name + " (" + tl_data.main.start_rough_year + " - " + tl_data.main.end_rough_year + ")";
                $('#TL_MAIN_ELEMENT_NAME').text(tl_title);

                let canvas = document.querySelector('#TL_MAIN_ELEMENT canvas');
                let canvas_jquery = $('#TL_MAIN_ELEMENT canvas');
                let main_element = $('#TL_MAIN_ELEMENT');
                let canvas_scale = 1;
                let canvas_width = main_element.width() / canvas_scale;
                let unscaled_canvas_width = main_element.width();

                while(canvas_width > 30000){
                    canvas_scale = canvas_scale * 2;
                    canvas_width = main_element.width() / canvas_scale
                }

                const canvas_width_reduction =  stripPX(canvas_jquery.css('margin-left')) +
                                                stripPX(canvas_jquery.css('margin-right'));

                unscaled_canvas_width = Math.round(unscaled_canvas_width - canvas_width_reduction);
                canvas.width = (canvas_width - canvas_width_reduction);
                canvas.height = canvas_jquery.height();
                canvas_jquery.css('max-width',unscaled_canvas_width);
                canvas_jquery.css('min-width',unscaled_canvas_width);

                //console.log(canvas_jquery.width());

                if (!canvas.getContext) {
                    return;
                }
                const ctx = canvas.getContext('2d');
                let ruler_marks = drawRuler(canvas_scale,tl_data.main,ctx,canvas.width);

                console.log("~~~~ RULER DATA ~~~~")
                console.log(ruler_marks);


                child_location = drawChildren(ruler_marks, children);
                //drawMarkers(ruler_marks, children, child_location);

                //$('.TL_ELEMENT_SHRUNK').hide();
                $('.TL_ELEMENT_SHRUNK').addClass('TL_ELEMENT_SHRUNK_HIDE');

                if(offset_element >= 0) {
                    console.log('#TL_ELEMENT_'+offset_element);
                    console.log(offset_element);
                    let scroll_child = $('#TL_ELEMENT_'+offset_element);
                    scroll_child.show();
                    console.log($('#TL_ELEMENT_'+offset_element).html());
                    console.log(scroll_child.offset().left);
                    console.log(scroll_child.width());
                    if(scroll_child !== undefined) {
                        left_side = scroll_child.offset().left;
                        scroll_to = left_side - (scroll_child.width() * 0.5);
                        console.log(scroll_to);
                        //$('#TL_ZONE').scrollLeft(scroll_to);
                        $('#TL_ZONE').animate({scrollLeft: scroll_to}, 800);
                    }
                }


                //data => //console.log(data)
            })
            .catch(error => console.error('Error:', error));

        time_line_data.then(result => {
            //console.log(result);
        })

    }); //dom loaded

    /*function drawMarkers(ruler_marks, children){

    }*/

    function stripPX(val){
        return parseInt(val.substring(0, val.length - 2));
    }

    function unZoom(){
        let query_aprams =  this.location.href.split("&");
        let new_url = query_aprams[0];
        query_aprams.forEach(function(param){
            if(!param.includes('tl_width')){
                new_url+'&'+param;
            }
        });
        this.location = new_url;
    }

    function setZoomPX( zoom, child_index){
        zoom = Math.round(zoom);
        let query_aprams =  this.location.href.split("&");
        //console.log(query_aprams);
        let new_url = query_aprams[0];
        query_aprams.forEach(function(param){
            if(!param.includes('tl_width')){
                new_url+'&'+param;
            }
        });
        new_url+='&tl_width='+zoom+'px&offset_element='+child_index;
        this.location = new_url;

    }

    function setZoomElement(child_index){
        $('#TL_ELEMENT_'+child_index).show();
        element = $('#TL_ELEMENT_'+child_index);
        console.log("child index: "+child_index);

        //$('#TL_ZONE_INNER').width()
        //let ratio = ($('#TL_ZONE').width() / element.width())*.5;
        console.log("element width: "+element.width());
        console.log("Inner width: "+$('#TL_ZONE_INNER').width());
        let ratio = ($('#TL_ZONE_INNER').width() / (element.width()*2));
        console.log("ratio " + ratio);
        let zoom = ($('#TL_ZONE').width() * ratio);
        //zoom = zoom - ((element.width() * ratio) * .5);
        console.log("Zoom : "+zoom);

        //might be a weird lucky accident this mostly works
        /*if(zoom < $('#TL_ZONE').width()) {
            ratio = element.width() / $('#TL_ZONE').width();
            console.log("neg ratio " + ratio);
            zoom = ($('#TL_ZONE_INNER').width() / ratio);
            zoom = zoom - (element.width() * .5);
            console.log("Zoom : " + zoom);
        }*/

        //let scroll_to =
        if(zoom < $('#TL_ZONE').width()){
            zoom = $('#TL_ZONE').width();
            offset=0;
        }
        setZoomPX(zoom,child_index);

    }

    function drawChildren(ruler_marks, children) {
        let lanes = [];
        let markers = [];

        //console.log(ruler_marks);
        child_locations = [];
        /*children.forEach((child, index, arr) => {
            if(!lanes[index]) {
                clone_lane = $("#TL_LANE_PROTO").clone();
                clone_lane.insertAfter("div.TL_LANE:last");
                clone_lane.attr('id', 'TL_CHILD_LANE_'+index);
                clone_lane.show();
                }
        });*/

        let lane_index = 1;
        let previous_child_index=0;
        children.forEach((child, child_index, arr) => {
            console.log("STARTING::::::::: ("+child_index+") "+child.name+ " " + child.association_start_year + " - " +child.association_end_year );
            child_locations[child_index] = [];
            if(ruler_marks['scale']=='monthly') {
                child_locations[child_index]['left'] = ruler_marks[child.association_start_year][child.association_start_month] + ruler_marks.ruler_lane_offset;
                child_locations[child_index]['right'] = ruler_marks[child.association_end_year][child.association_end_month];
                child_locations[child_index]['width'] = (child_locations[child_index]['right'] - child_locations[child_index]['left']) + ruler_marks.ruler_lane_offset;
            }else if(ruler_marks['scale']=='yearly'){
                child_locations[child_index]['left'] = ruler_marks[child.association_start_year][0] + ruler_marks.ruler_lane_offset;
                child_locations[child_index]['right'] = ruler_marks[child.association_end_year][0];
                child_locations[child_index]['width'] = (child_locations[child_index]['right'] - child_locations[child_index]['left']) + ruler_marks.ruler_lane_offset ;
            }

            let lane_with_space = 0;

            if(child_index == 0){
                lane_index = 0;
                lane_with_space = 0;
            }else{
                //console.log("~~~~~~~~ index "+child_index+", search lanes ~~~~~~~~~~");
                lane_with_space = 0;
                lanes.forEach((lane, this_lane_index) =>{
                    let space_available = true;
                    if(lane_with_space == 0) {
                        //console.log("checking lane " + this_lane_index);
                        //console.log(lane.occupied_spaces);
                        lane.occupied_spaces.forEach((space, space_index) => {
                            //console.log(space);

                            if (child_locations[child_index]['left']  == space[0] ||
                                child_locations[child_index]['right'] == space[1] ||
                                (child_locations[child_index]['left'] < space[0] && child_locations[child_index]['right'] > space[0]) ||
                                (child_locations[child_index]['left'] < space[1] && child_locations[child_index]['right'] > space[1]) ||
                                (child_locations[child_index]['left'] > space[0] && child_locations[child_index]['right'] < space[1]) ||
                                (child_locations[child_index]['left'] < space[0] && child_locations[child_index]['right'] > space[1])
                            ) {

                                //console.log("collision found in " + this_lane_index + "! with object" + space_index);
                                //console.log("Child: L" + child_locations[child_index]['left'] + "  R" + child_locations[child_index]['right']);
                                //console.log("occupied space: " + space)
                                space_available = false;

                            } else {
                                //console.log("NO collision found in " + this_lane_index + "! with object" + space_index);
                            }

                        });
                        if (space_available) {
                            //console.log('this lane (' + this_lane_index + ') has space for ' + child.name)
                            lane_with_space = this_lane_index;
                        }
                    }
                });

            }

            if(lane_with_space == 0){
                //console.log("NO lane with space, create one");
                lane_index ++;
                clone_lane = $("#TL_LANE_PROTO").clone();
                clone_lane.insertAfter("div.TL_LANE:last");
                clone_lane.attr('id', 'TL_CHILD_LANE_'+lane_index);
                clone_lane.show();
                lane_with_space = lane_index;
                lanes[lane_index] = clone_lane;
            }

            ////console.log("PLACING:::::::::: "+child.name+ " " + child.association_start_year + " - " +child.association_end_year );
            clone_child=$("#TL_ELEMENT_PROTO").clone();
            clone_child.attr('id', 'TL_ELEMENT_'+child_index);
            $("#TL_CHILD_LANE_"+lane_with_space).append(clone_child);


            //change offset months to named months
            child.association_start_month += 1;
            child.association_end_month += 1;

            lable = child.name+ " <br /> ("+ child.association_start_month +", " + child.association_start_year +   " - " + child.association_end_month +", " + child.association_end_year + ")"
            $('<p>'+lable+'</p>').appendTo('#TL_ELEMENT_'+child_index);
            clone_child.addClass('TL_ELEMENT_CHILD');
            clone_child.css('left',child_locations[child_index]['left']+'px');
            clone_child.css('min-width',child_locations[child_index]['width']+'px');
            clone_child.css('max-width',child_locations[child_index]['width']+'px');

            if(child_locations[child_index]['width'] > min_child_width &&
                clone_child.height() < stripPX($(".TL_LANE").css('min-height'))) {
                clone_child.attr('data-shrunk',false);
                child_locations[child_index]['hidden'] = false;
            }else{
                //child_locations[child_index]['width'] = min_child_width;
                clone_child.attr('data-shrunk',true);
                clone_child.addClass('TL_ELEMENT_SHRUNK');
                //clone_child.css('min-width',min_child_width+"px");
                child_locations[child_index]['hidden'] = true;
            }
            clone_child.removeClass('PROTO');
            clone_child.show();

            ////console.log('FIX HEIGHTS');
            /*if ($("#TL_CHILD_LANE_"+lane_with_space).height() < $('#TL_ELEMENT_'+child_index).height()){
                $('#TL_CHILD_LANE_'+lane_with_space).css('min-height',$('#TL_ELEMENT_'+child_index).height()+"px");
            }*/

            if(!lanes[lane_with_space]['occupied_spaces']) lanes[lane_with_space]['occupied_spaces']=[];
            lanes[lane_with_space]['occupied_spaces'].push([child_locations[child_index]['left'], child_locations[child_index]['right']]);


            /** Setup the markers **/

            const this_markers_element = $('#TL_ELEMENT_' + child_index);
            const this_marker_left = child_locations[child_index]['left'] - ($("#RULER_MARKER_ORIGINAL").width()/2);
            const this_marker_right = this_marker_left+20;
            let marker_collision = false;

            //console.log("!!! MARKER SO FAR !!!")
            //console.log(markers);
            if(markers.length > 1) {
                markers.forEach(function (marker, marker_index, arr) {
                    if (this_marker_left == marker['left'] ||
                    (this_marker_left < marker['left'] && this_marker_right > marker['left']) ||
                    (this_marker_left > marker['left'] && this_marker_left < marker['right'])) {
                        //console.log(marker_index+' marker collision for child ' + child_index);
                        //console.log(marker_index+"    :: "+marker['left'] + ", "+marker['right']);
                        //console.log("This :: "+this_marker_left + ", "+this_marker_right);
                        marker_collision = true;
                        if(!markers[marker_index]['children']) markers[marker_index]['children'] =[];

                        markers[marker_index]['children'].push(child_index);

                        tool_tip_select=$('#RULER_MARKER' +marker_index+ ' .tooltiptext')
                        existing_tooltip = tool_tip_select.html();
                        tool_tip_select.html(existing_tooltip+",<br /> "+child.name);

                        const this_sub_marker = $('#RULER_MARKER' +marker_index);
                        const this_sub_markers_element = $('#TL_ELEMENT_' + marker_index);


                        //$('#RULER_MARKER' + marker_index + " span.elements_number").html("2");
                        ruler_marker_number_selection =$('#RULER_MARKER' + marker_index + " span.elements_number");
                        ruler_marker_number = ruler_marker_number_selection.html();
                        ruler_marker_number = parseInt(ruler_marker_number)  + 1;
                        ruler_marker_number_selection.html(ruler_marker_number) ;

                        this_sub_marker.on("mouseover", function () {
                            if(this_markers_element.data('shrunk')){
                                console.log("fading in sub marker element "+child.name);
                                this_markers_element.addClass('TL_ELEMENT_SHRUNK_SHOW');
                                this_markers_element.removeClass('TL_ELEMENT_SHRUNK_HIDE');
                                this_markers_element.fadeIn();
                            }else{
                                console.log("coloring sub marker element "+child.name);
                                this_markers_element.css('background-color', 'yellow');
                            }
                            /*setTimeout(function(){
                                this_sub_markers_element.css('background-color', '');
                                this_sub_markers_element.css('z-index', 1);
                                if(this_sub_markers_element.data('shrunk')) {
                                    this_sub_markers_element.hide();
                                    this_sub_markers_element.removeClass('TL_ELEMENT_SHRUNK');
                                }
                            },10000);*/

                        });
                        this_sub_marker.on("mouseout", function () {
                            this_markers_element.css('background-color', '');
                            this_markers_element.css('z-index', 1);
                            if(this_markers_element.data('shrunk')) {
                                //this_markers_element.hide();
                                this_markers_element.removeClass('TL_ELEMENT_SHRUNK_SHOW');
                                this_markers_element.addClass('TL_ELEMENT_SHRUNK_HIDE');
                            }
                        });
                    }
                });
            }

            if(!marker_collision) {

                //console.log("No marker collision");
                clone_marker = $("#RULER_MARKER_ORIGINAL").clone();
                clone_marker.attr('id', 'RULER_MARKER' + child_index);

                $("#TL_RULER").append(clone_marker);

                //move marker over to the location of the child element - half its width
                clone_marker.css('left', this_marker_left + 'px');
                if(child_index != '<%= offset_element %>'){
                    clone_marker.on("click", function () {
                        if(this_markers_element.data('shrunk')){
                            this_markers_element.removeClass('TL_ELEMENT_SHRUNK_HIDE');
                            this_markers_element.addClass('TL_ELEMENT_SHRUNK_SHOW');
                            this_markers_element.show();
                        }
                        setZoomElement(child_index);
                    });
                }else{
                    clone_marker.css('cursor', 'zoom-out');
                    clone_marker.on("click", function () {
                        unZoom();
                    });
                }

                clone_marker.on("mouseover", function () {

                    if(this_markers_element.data('shrunk')) {
                        //console.log("fading in marker element "+child.name);
                        this_markers_element.css('z-index', 2);
                        this_markers_element.addClass('TL_ELEMENT_SHRUNK_SHOW');
                        this_markers_element.removeClass('TL_ELEMENT_SHRUNK_HIDE');
                        this_markers_element.fadeIn();
                    }else{
                        //console.log("dying marker element "+child.name);
                        this_markers_element.css('background-color', 'yellow');
                    }

                    /*setTimeout(function(){
                        this_markers_element.css('z-index', 1);
                        this_markers_element.css('background-color', '');
                        if(this_markers_element.data('shrunk')){
                            this_markers_element.removeClass('TL_ELEMENT_SHRUNK');
                            this_markers_element.hide();
                        }
                    },10000);*/
                });

                clone_marker.on("mouseout", function () {
                    this_markers_element.css('z-index', 1);
                    this_markers_element.css('background-color', '');
                    if(this_markers_element.data('shrunk')){
                        this_markers_element.removeClass('TL_ELEMENT_SHRUNK_SHOW');
                        this_markers_element.addClass('TL_ELEMENT_SHRUNK_HIDE');
                        //this_markers_element.hide();
                    }
                });

                $('#RULER_MARKER' +child_index+ ' .tooltiptext').html(child.name);

                if(child_locations[child_index]['hidden']){
                    $('#RULER_MARKER' +child_index+ ' .RULER_MARKER_BOT').addClass('RULER_MARKER_BOT_UNSEEN');
                    $('#RULER_MARKER' +child_index+ ' .RULER_MARKER_TOP').addClass('arrow-up_UNSEEN');
                }

                markers[child_index]=[];
                markers[child_index]['left'] = this_marker_left;
                markers[child_index]['right'] = this_marker_right;
                markers[child_index]['children'] = [];
                //console.log(markers);
            }
            previous_child_index = child_index;
        });

        //console.log("lanes: ");
        //console.log(lanes);
        //console.log("child locations : ");
        //console.log(child_locations);
        return child_locations;
    } //END drawChildren

    function drawRuler(canvas_scale,tl_object,ctx,canvas_width){

       console.log("RULER CANVAS SCALE:::: "+canvas_scale);
       let canvas_correction = 0;
        if(canvas_scale > 1) {
            canvas_correction = 10 * canvas_scale;
        }
        console.log("Canvas correction "+canvas_correction)
        let min_yearly_pixel_time = 45;
        let time_scale = 1;
        let sub_tick_sub_division = 12;
        let tall_sub_tick = 2;
        let sub_tick_scale = 'monthly';
        let ruler_marks = [];
        let pixel_time = Math.round((canvas_width * canvas_scale) / (tl_object.year_duration + 1.75));
        //let pixel_time = main_element.width() / (tl_object.year_duration);
        console.log('Pixel tile: '+pixel_time);
        //console.log('end rough month: '+tl_object.end_rough_month);

        if(pixel_time < min_yearly_pixel_time){
            //time_scale = 10; //10 years
            time_scale = time_scaling = 5;
            tall_sub_tick = 5;
            tl_object.start_rough_year = tl_object.start_render_year;
            pixel_time = (canvas_width / (tl_object.render_year_duration + (1/time_scaling))) * time_scale;
            sub_tick_scale = 'yearly';
            while(time_scale * pixel_time < min_yearly_pixel_time){ // scale until time scale below threashhold
                if(time_scale < 10) time_scale = time_scaling = 10;
                if(time_scale * pixel_time < min_yearly_pixel_time){
                    time_scale = time_scale * time_scaling;
                }
            }
            /*//console.log("remainder: ");
            //console.log(tl_object.render_year_duration % time_scale);*/
            //pixel_time = main_element.width() / ((tl_object.year_duration / time_scale) + ((tl_object.year_duration % time_scale) / 2));

            sub_tick_sub_division = time_scale;
        }
        ruler_marks['scale']=sub_tick_scale;


        //console.log("year duration: "+tl_object.year_duration);
        //console.log("width: "+canvas_width);
        console.log("TIME SCALE: "+time_scale);
        console.log("PIXEL TIME: "+pixel_time);
        console.log("width / PIXEL TIME: "+canvas_width / pixel_time);
        console.log("width / sub tick: "+canvas_width / sub_tick_sub_division);


        //assumes scale = yearly
        let line_x = 0;
        let line_x_increment = (pixel_time / canvas_scale);
        let year_increment = time_scale;
        let sub_tick_increment = (line_x_increment / sub_tick_sub_division);

        for(year_count = tl_object.start_rough_year; year_count <= tl_object.end_rough_year; year_count = year_count + year_increment) {

            ctx.strokeStyle = 'black 1px solid';
            ctx.beginPath();
            //ctx.moveTo(line_x, 40);
            ctx.moveTo(line_x, 35);
            ctx.lineTo(line_x, 50);
            ctx.stroke();

            ctx.font = "15px Arial";
            ctx.fillText(year_count, line_x - 3, 30);

            if(year_count <= tl_object.end_rough_year) {
                for (sub_tick = 0; sub_tick < sub_tick_sub_division; sub_tick++) {
                    if(sub_tick_scale == 'yearly' && sub_tick+year_count >= tl_object.end_rough_year + 1) break;
                    if(sub_tick_scale == 'monthly' && year_count == tl_object.end_rough_year && sub_tick >= tl_object.end_rough_month + 1) break;

                    ctx.strokeStyle = 'black 1px solid';
                    ctx.beginPath();
                    if ((sub_tick_scale == 'yearly' && tall_sub_tick && sub_tick % tall_sub_tick == 0) ||
                        (sub_tick_scale == 'monthly' && (sub_tick == 5))) {
                        ctx.moveTo(line_x + (sub_tick * sub_tick_increment), 40);
                    } else {
                        ctx.moveTo(line_x + (sub_tick * sub_tick_increment), 45);
                    }
                    ctx.lineTo(line_x + (sub_tick * sub_tick_increment), 50);
                    ctx.stroke();

                    if(sub_tick_scale == 'yearly'){
                        if(!ruler_marks[year_count+sub_tick]) ruler_marks[year_count+sub_tick] = []; ruler_marks[year_count+sub_tick][0] = [];
                        ruler_marks[year_count+sub_tick][0]=((line_x + (sub_tick * sub_tick_increment)) * canvas_scale) + canvas_correction;
                    }else if(sub_tick_scale == 'monthly'){
                        if(!ruler_marks[year_count]) ruler_marks[year_count]= []; ruler_marks[year_count][sub_tick] = [];
                        ruler_marks[year_count][sub_tick]=((line_x + (sub_tick * sub_tick_increment)) * canvas_scale) + canvas_correction;
                    }

                }
            }
            line_x = line_x + line_x_increment;

        }
        //console.log("year "+year_count);
        ruler_marks.ruler_lane_offset = $("#TL_RULER canvas").offset().left - $("#TL_RULER canvas").parents('.TL_LANE').offset().left;
        return ruler_marks;
    }
</script>

<!--
<h1>Main Content</h1>
<p><%= mid_content %></p>
-->
<div id="TL_MAIN_ELEMENT_NAME" onClick="unZoom()"></div>
<div id="TL_ZONE">

    <div id="TL_ZONE_INNER">
        <div class="TL_LANE">

            <div id="TL_MAIN_ELEMENT" class="TL_ELEMENT">

                <div id="TL_RULER">
                    <canvas></canvas>
                    <div id="RULER_MARKER_ORIGINAL" class="RULER_MARKER">
                        <span class="tooltiptext">Tooltip text</span>
                        <div class="RULER_MARKER_TOP arrow-up"></div>
                        <div class="RULER_MARKER_BOT"><span class="elements_number">1</span></div>
                    </div>
                </div>
            </div>
        </div>  <!-- end lane -->

        <div class="TL_LANE TL_CHILD_LANE PROTO" id="TL_LANE_PROTO">

        </div>
        <div class="TL_ELEMENT PROTO" id="TL_ELEMENT_PROTO">
            <div class="TL_ELEMENT_NAME"></div>
            <div class="TL_ELEMENT_BODY">
                <div class="TL_ELEMENT_ICON"></div>

            </div>
        </div>
    </div>
</div>


<%- include('partials/footer') %>